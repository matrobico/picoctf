# format string 0 (2024)
> Binary Exploitation

### Description
> Are overflows just a stack concern?
> 
> Download the binary [here](https://artifacts.picoctf.net/c_tethys/13/chall).
>
> Download the source [here](https://artifacts.picoctf.net/c_tethys/13/chall.c).
>
> Additional details will be available after launching your challenge instance.
>
> **Hint 1: What part of the heap do you have control over and how far is it from the safe_var?**

### Solution
Taking a look at the source binary provided to use, we can see a string comparison between `safe_var` and "bico" happening in the `check_win()` function, as well as `malloc()` calls to reserve space on the heap. It would seem we need to overflow the input buffer enough to overwrite `safe_var`. Upon closer inspection of the source, there's no input sanitization (obviously) and the input buffer is initially set to "pico".

Writing to the input buffer and printing it out (via the program's options), we can see that anything we write replaces the contents of the input buffer. Furthermore, since we're provided the addresses of the variables, we can see how many bytes we have to write to reach the `safe_var` address. Since it's 32 bytes away, we can write 33 "A" characters and voila, we can print out the flag.


### Flag
`picoCTF{my_first_heap_overflow_4fa6dd49}`
