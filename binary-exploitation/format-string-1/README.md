# format string 1
> Binary Exploitation

### Description
> Patrick and Sponge Bob were really happy with those orders you made for them, but now they're curious about the secret menu. Find it, and along the way, maybe you'll find something else of interest!
> 
> Download the binary [here](https://artifacts.picoctf.net/c_mimas/43/format-string-1).
>
> Download the source [here](https://artifacts.picoctf.net/c_mimas/43/format-string-1.c).
>
> Additional details will be available after launching your challenge instance.
>
> **Hint 1: https://lettieri.iet.unipi.it/hacking/format-strings.pdf**
> **Hint 2: Is this a 32-bit or 64-bit binary?**

### Solution
The key to solving this challenge is to understand format specifier attacks. In this case, the key issue is the use of `printf(buf)` to print out the buffer holding user supplied input. Printing out data in this way allows an attacker to provide format specifiers to the input, causing the program to read values from memory where it expects arguments to be *even when there are none*. The correct way to program in this case would be to use either `puts(buf)` or `printf("%s", buf)`, where `printf` is instructed to look specifcally for a string inside of the buf buffer.

Identifying this issue in the code makes crafting an attack possible. First, we'll need to understand the layout of the stack (or registers since it's 64-bit?)to read from with our attack. We can see that the flag is read right before secret2 is, so that tells us flag resides just above secret2 on the stack. Since this is a 64-bit binary, we can use "%lx" to move in 8-byte increments to grab our data.

Starting from the 14th "%lx", we start to see the beginnings of a flag. Printing out a bit further, we see:
`0x7b4654436f636970 0x355f31346d316e34 0x3478345f33317937 0x31395f673431665f 0x7d653464663533`
`{FTCocip5_14m1n44x4_31y719_g41f_}`

Taking into account this is LSB and re-arranging, we get:
`0x7069636f4354467b 0x346e316d34315f35 0x377931335f347834 0x5f663134675f3931 0x3335666434657d`
`picoCTF{4n1m41_57y13_4x4_f14g_9135fd4e}`

TODO:
- Why use %pf as a solution?
    - "%p" also prints out 8 bytes of data (I guess because a pointer is 8 bytes) at a time, like "%lx".
- How many are necessary and why?
    - It seems we start printing the flag at the 14th "%lx" or "%p", whichever is used. This is 112 bytes. It's possible we needed to pass the 64 for secret2, then the first (or last?) 48 of the flag variable before hitting the actual flag. Maybe this means only 16 bytes were used for the flag (112-64 - the extra 48 before hitting the flag).
- What exactly does the layout of the stack look like when the call to printf occurs?
    - I think it's, from top grown down, secret1 -> flag -> secret2 -> buf?? -> printf call


### Flag
`picoCTF{4n1m41_57y13_4x4_f14g_9135fd4e}`
